<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AstroMiner v3 - √âlite Galactique</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400&display=swap');

        :root {
            --primary: #00d2ff;
            --shield: #0088ff;
            --danger: #ff3333;
            --warning: #ffaa00;
            --success: #00ff88;
            --bg: #050510;
            --panel: rgba(10, 15, 25, 0.95);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Roboto', sans-serif;
            color: white;
            user-select: none;
        }

        canvas { display: block; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* HUD elements */
        .hud-panel {
            position: absolute;
            padding: 10px 20px;
            background: rgba(0, 10, 20, 0.85);
            border: 1px solid var(--primary);
            border-radius: 4px;
            pointer-events: auto;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.15);
            backdrop-filter: blur(2px);
        }

        #stats-panel {
            top: 20px; left: 20px;
            display: flex; flex-direction: column; gap: 6px;
            min-width: 200px;
        }

        #cargo-panel {
            top: 20px; right: 20px;
            text-align: right;
            min-width: 180px;
        }

        .bar-wrapper {
            position: relative;
            margin-top: 4px;
        }

        .bar-label {
            font-size: 0.75em; color: #aaa; letter-spacing: 1px;
            display: flex; justify-content: space-between;
        }

        .bar-container {
            width: 100%; height: 8px;
            background: #111;
            border: 1px solid #444;
            position: relative;
            overflow: hidden;
        }

        .bar-fill { height: 100%; transition: width 0.1s linear; }
        .shield-fill { background: linear-gradient(90deg, #0044aa, #0088ff); box-shadow: 0 0 10px #0088ff; }
        .health-fill { background: linear-gradient(90deg, #880000, #ff3333); }
        .fuel-fill { background: linear-gradient(90deg, #aa6600, #ffaa00); }
        .cargo-fill { background: linear-gradient(90deg, #006633, #00ff88); }

        /* Boss Warning */
        #boss-warning {
            position: absolute;
            top: 20%; left: 50%;
            transform: translate(-50%, -50%);
            color: var(--danger);
            font-family: 'Orbitron', sans-serif;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 20px var(--danger);
            text-align: center;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse { 0% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); } 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); } }

        /* Notifications */
        #notification-area {
            position: absolute;
            top: 15%; left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            display: flex; flex-direction: column; gap: 5px;
        }

        .message {
            background: rgba(0, 0, 0, 0.8);
            border-left: 3px solid var(--primary);
            color: #fff;
            padding: 8px 20px;
            animation: fadeUp 2.5s forwards;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @keyframes fadeUp {
            0% { opacity: 0; transform: translateY(10px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* Menus */
        .menu-screen {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--panel);
            border: 2px solid var(--primary);
            padding: 40px;
            width: 85%; max-width: 700px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 210, 255, 0.15);
            pointer-events: auto;
            display: none;
        }

        h1, h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary);
            margin-top: 0;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }

        .btn {
            background: rgba(0, 210, 255, 0.05);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 12px 24px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            font-size: 15px;
            margin: 8px;
            transition: 0.2s;
            text-transform: uppercase;
            min-width: 150px;
        }

        .btn:hover { background: var(--primary); color: #000; box-shadow: 0 0 15px var(--primary); }
        .btn:disabled { border-color: #555; color: #555; cursor: not-allowed; background: transparent; box-shadow: none; }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin: 20px 0;
            text-align: left;
        }

        .upgrade-card {
            border: 1px solid #444;
            padding: 12px;
            background: rgba(255,255,255,0.03);
            transition: 0.2s;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .upgrade-card:hover { border-color: var(--primary); background: rgba(0, 210, 255, 0.05); }

        .upgrade-card h4 { margin: 0 0 5px 0; color: #fff; font-size: 0.85em; }
        .cost { color: var(--success); font-weight: bold; font-size: 1em; margin: 5px 0; }
        .lvl-badge { float: right; color: #888; font-size: 0.8em; }

        /* Radar */
        #radar {
            position: absolute;
            bottom: 20px; left: 20px;
            width: 120px; height: 120px;
            border-radius: 50%;
            border: 2px solid #333;
            background: radial-gradient(circle, rgba(0,20,40,0.9) 0%, rgba(0,0,0,0.95) 100%);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            pointer-events: none;
            overflow: hidden;
        }
        
        #radar-scan {
            position: absolute;
            top: 50%; left: 50%;
            width: 50%; height: 50%;
            background: linear-gradient(45deg, rgba(0,255,136,0) 0%, rgba(0,255,136,0.2) 100%);
            transform-origin: top left;
            animation: scan 3s infinite linear;
        }

        @keyframes scan { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        
        .radar-blip {
            position: absolute;
            width: 4px; height: 4px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .controls-hint {
            position: absolute;
            bottom: 20px; right: 20px;
            color: #667;
            font-size: 11px;
            text-align: right;
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        
        <div id="boss-warning">‚ö†Ô∏è ALERTE DREADNOUGHT ‚ö†Ô∏è</div>

        <!-- HUD -->
        <div id="hud" style="display:none;">
            <div id="stats-panel" class="hud-panel">
                <div style="font-size: 1.2em; letter-spacing: 1px; border-bottom: 1px solid #333; padding-bottom: 5px;">
                    CR√âDITS: <span id="credits-display" style="color:var(--success)">0</span>
                </div>
                
                <div class="bar-wrapper">
                    <div class="bar-label"><span>BOUCLIER</span> <span id="shield-val">100%</span></div>
                    <div class="bar-container"><div id="shield-bar" class="bar-fill shield-fill"></div></div>
                </div>

                <div class="bar-wrapper">
                    <div class="bar-label"><span>COQUE</span> <span id="hull-val">100%</span></div>
                    <div class="bar-container"><div id="hull-bar" class="bar-fill health-fill"></div></div>
                </div>
                
                <div class="bar-wrapper">
                    <div class="bar-label"><span>CARBURANT</span></div>
                    <div class="bar-container"><div id="fuel-bar" class="bar-fill fuel-fill"></div></div>
                </div>
            </div>

            <div id="cargo-panel" class="hud-panel">
                <div style="font-size: 1em; border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 5px;">
                    SOUTE <span id="cargo-text" style="color:var(--warning)">0/10</span>
                </div>
                <div class="bar-container" style="margin-left: auto;"><div id="cargo-bar" class="bar-fill cargo-fill" style="width:0%"></div></div>
                <div style="margin-top:8px; font-size: 0.85em; color:#bbb; display:grid; grid-template-columns: 1fr 1fr 1fr; gap:5px;">
                    <span>Fe: <b id="res-iron" style="color:#aaa">0</b></span>
                    <span>Or: <b id="res-gold" style="color:#fd0">0</b></span>
                    <span>Cr: <b id="res-crystal" style="color:#d0f">0</b></span>
                </div>
            </div>

            <div id="radar">
                <div id="radar-scan"></div>
            </div>
            
            <div class="controls-hint">
                [WASD] Moteurs<br>
                [ESPACE] Tirer / Miner<br>
                Ramassez les caisses pour survivre
            </div>
        </div>

        <div id="notification-area"></div>

        <!-- Screens -->
        <div id="start-screen" class="menu-screen">
            <h1 style="font-size: 3em; margin-bottom: 5px;">AstroMiner <span style="font-size:0.4em; color:var(--primary); vertical-align: super;">v3.0</span></h1>
            <h3 style="color: white; font-weight: normal; margin-top: 0;">√âLITE GALACTIQUE</h3>
            
            <div style="margin: 20px 0; border-top: 1px solid #333; border-bottom: 1px solid #333; padding: 20px; text-align: left; font-size: 0.9em; color: #ccc;">
                <p>üöÄ <b>MISSION :</b> R√©coltez des ressources et survivez.</p>
                <p>üõ°Ô∏è <b>BOUCLIER :</b> Prot√®ge votre coque. Se r√©g√©n√®re hors combat.</p>
                <p>‚ò†Ô∏è <b>BOSS :</b> Un Dreadnought pirate r√¥de dans le secteur.</p>
                <p>üì¶ <b>BUTIN :</b> Les pirates l√¢chent des caisses de survie.</p>
            </div>
            
            <button class="btn" onclick="startGame()">D√âMARRER SYST√àMES</button>
            <br><br>
            <small id="save-found-msg" style="color: var(--success); display:none;">PROFIL PILOTE CHARG√â</small>
        </div>

        <div id="station-menu" class="menu-screen">
            <h2>STATION ALPHA</h2>
            <p style="color:#889;">Zone de Commerce & Ravitaillement</p>
            
            <div style="display:flex; justify-content: center; gap: 15px; margin: 25px 0;">
                <button class="btn" onclick="sellResources()">VENDRE TOUT (<span id="sell-value" style="color: white;">0</span>$)</button>
                <button class="btn" onclick="refillServices()">RECHARGE TOTALE (50$)</button>
            </div>

            <h3 style="text-align: left; border-bottom: 1px solid #333; padding-bottom: 5px; font-size: 1em;">AM√âLIORATIONS VAISSEAU</h3>
            <div class="upgrade-grid">
                <div class="upgrade-card">
                    <h4>MOTEURS <span id="lvl-speed" class="lvl-badge">LVL 1</span></h4>
                    <p class="cost"><span id="cost-speed">100</span> $</p>
                    <button class="btn" style="width:100%; margin:0; padding:6px;" id="btn-up-speed" onclick="buyUpgrade('speed')">Acheter</button>
                </div>
                <div class="upgrade-card">
                    <h4>LASER <span id="lvl-laser" class="lvl-badge">LVL 1</span></h4>
                    <p class="cost"><span id="cost-laser">150</span> $</p>
                    <button class="btn" style="width:100%; margin:0; padding:6px;" id="btn-up-laser" onclick="buyUpgrade('laser')">Acheter</button>
                </div>
                <div class="upgrade-card">
                    <h4>SOUTE <span id="lvl-cargo" class="lvl-badge">LVL 1</span></h4>
                    <p class="cost"><span id="cost-cargo">200</span> $</p>
                    <button class="btn" style="width:100%; margin:0; padding:6px;" id="btn-up-cargo" onclick="buyUpgrade('cargo')">Acheter</button>
                </div>
                <div class="upgrade-card">
                    <h4>COQUE <span id="lvl-hull" class="lvl-badge">LVL 1</span></h4>
                    <p class="cost"><span id="cost-hull">150</span> $</p>
                    <button class="btn" style="width:100%; margin:0; padding:6px;" id="btn-up-hull" onclick="buyUpgrade('hull')">Acheter</button>
                </div>
                <div class="upgrade-card" style="border-color: var(--shield);">
                    <h4>BOUCLIER <span id="lvl-shield" class="lvl-badge">LVL 1</span></h4>
                    <p class="cost"><span id="cost-shield">250</span> $</p>
                    <button class="btn" style="width:100%; margin:0; padding:6px;" id="btn-up-shield" onclick="buyUpgrade('shield')">Acheter</button>
                </div>
            </div>

            <button class="btn" style="border-color: var(--danger); color: var(--danger); width: 100%;" onclick="closeStation()">SORTIR DU HANGAR</button>
        </div>

        <div id="game-over-screen" class="menu-screen">
            <h1 style="color: var(--danger)">√âCHEC MISSION</h1>
            <p id="death-reason" style="font-size: 1.2em; color: white;">Vaisseau d√©truit.</p>
            <div style="margin: 20px 0; color: #888;">
                <p>Protocole d'√©vacuation activ√©.</p>
                <p>Cargaison perdue.</p>
            </div>
            <button class="btn" onclick="respawn()">NOUVEAU VAISSEAU</button>
        </div>
    </div>

<script>
/**
 * ASTROMINER v3 - ELITE GALACTIQUE
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIG & STATE ---
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const GAME_STATE = { MENU: 0, PLAYING: 1, STATION: 2, GAMEOVER: 3 };
let currentState = GAME_STATE.MENU;

// Constants
const WORLD_SIZE = 6000;
const STATION_SIZE = 180;
const ENEMY_SPAWN_RATE = 0.003; 
let bossSpawnTimer = 0;
const BOSS_INTERVAL = 3000; // Frames until boss check (approx 50s)

// Entities Arrays
let particles = [];
let asteroids = [];
let stars = [];
let popups = [];
let enemies = [];
let projectiles = []; // Both player and enemy use simple projectile logic but separated arrays for collision
let enemyProjectiles = [];
let loots = [];

// Input
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    w: false, s: false, a: false, d: false, " ": false
};
window.addEventListener('keydown', (e) => keys[e.key] = true);
window.addEventListener('keyup', (e) => keys[e.key] = false);

function randomRange(min, max) { return Math.random() * (max - min) + min; }
function distance(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

// --- SAVE SYSTEM ---
const SAVE_KEY = 'astroMinerV3_save';
let playerData = {
    credits: 0,
    upgrades: { speed: 1, laser: 1, cargo: 1, hull: 1, shield: 1 }
};

function saveGame() {
    localStorage.setItem(SAVE_KEY, JSON.stringify(playerData));
    showNotification("Sauvegarde effectu√©e", "#00ff88");
}
function loadGame() {
    const data = localStorage.getItem(SAVE_KEY);
    if (data) {
        let loaded = JSON.parse(data);
        // Migration check for v2 to v3
        if(!loaded.upgrades.shield) loaded.upgrades.shield = 1;
        playerData = loaded;
        document.getElementById('save-found-msg').style.display = 'block';
        updateUpgradeUI();
    }
}

// --- CLASSES ---

class Camera {
    constructor() { this.x = 0; this.y = 0; }
    follow(target) {
        let targetX = target.x - canvas.width / 2;
        let targetY = target.y - canvas.height / 2;
        this.x += (targetX - this.x) * 0.1;
        this.y += (targetY - this.y) * 0.1;
    }
}

class Ship {
    constructor() { this.reset(); }
    
    reset() {
        this.x = 0; this.y = 0;
        this.vx = 0; this.vy = 0;
        this.angle = -Math.PI / 2;
        this.rotationSpeed = 0.07;
        this.friction = 0.98;
        this.radius = 18;
        this.dead = false;
        this.inStationZone = false;
        
        this.applyStats();
        this.hull = this.maxHull;
        this.shield = this.maxShield;
        this.fuel = this.maxFuel;
        this.cargo = { iron: 0, gold: 0, crystal: 0 };
        this.shieldRegenTimer = 0;
    }

    applyStats() {
        const u = playerData.upgrades;
        this.maxSpeed = 3.5 + (u.speed * 1.2);
        this.thrust = 0.18 + (u.speed * 0.04);
        this.maxHull = 100 + (u.hull * 50);
        this.maxShield = 40 + (u.shield * 40);
        this.shieldRegenRate = 0.1 + (u.shield * 0.05);
        this.maxFuel = 1000 + (u.speed * 100);
        this.maxCargo = 10 + (u.cargo * 5);
        this.miningPower = 0.8 + (u.laser * 0.6);
        this.laserRange = 230;
    }

    getCargoTotal() { return this.cargo.iron + this.cargo.gold + this.cargo.crystal; }

    update() {
        if (this.dead) return;

        // Rotation & Movement
        if (keys.ArrowLeft || keys.a) this.angle -= this.rotationSpeed;
        if (keys.ArrowRight || keys.d) this.angle += this.rotationSpeed;

        if (keys.ArrowUp || keys.w) {
            if (this.fuel > 0) {
                this.vx += Math.cos(this.angle) * this.thrust;
                this.vy += Math.sin(this.angle) * this.thrust;
                this.fuel -= 0.6;
                this.spawnThrusters();
            } else {
                if (Math.random() < 0.02) showNotification("ALERTE CARBURANT", "#ffaa00");
            }
        }
        
        // Physics
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;

        // Map Bounds
        if (Math.abs(this.x) > WORLD_SIZE) this.vx *= -1;
        if (Math.abs(this.y) > WORLD_SIZE) this.vy *= -1;

        // Action
        if (keys[" "] && this.fuel > 0) this.action();

        // Station Logic
        const dToStation = distance(this.x, this.y, 0, 0);
        if (dToStation < STATION_SIZE/2 + this.radius) {
            if (Math.abs(this.vx) < 1.5 && Math.abs(this.vy) < 1.5) openStation();
            else if (!this.inStationZone) {
                showNotification("Ralentir pour amarrage", "#ffaa00");
                this.inStationZone = true;
            }
        } else this.inStationZone = false;

        // Shield Regen
        if (this.shield < this.maxShield) {
            this.shieldRegenTimer++;
            if (this.shieldRegenTimer > 120) { // 2 seconds without damage
                this.shield += this.shieldRegenRate;
                if(this.shield > this.maxShield) this.shield = this.maxShield;
            }
        }

        if (this.hull <= 0) die("Coque d√©truite");
        if (this.fuel <= 0 && Math.abs(this.vx) < 0.1) die("Panne s√®che");
    }

    takeDamage(amount) {
        this.shieldRegenTimer = 0;
        if (this.shield > 0) {
            this.shield -= amount;
            // Visual shield hit
            ctx.beginPath();
            ctx.arc(this.x - camera.x, this.y - camera.y, this.radius + 10, 0, Math.PI*2);
            ctx.strokeStyle = '#0088ff';
            ctx.lineWidth = 3;
            ctx.stroke();
            if (this.shield < 0) {
                this.hull += this.shield; // Overflow damage
                this.shield = 0;
            }
        } else {
            this.hull -= amount;
        }
        camera.x += randomRange(-3, 3);
        camera.y += randomRange(-3, 3);
    }

    spawnThrusters() {
        const x1 = this.x - Math.cos(this.angle) * 20 + Math.cos(this.angle + Math.PI/2) * 8;
        const y1 = this.y - Math.sin(this.angle) * 20 + Math.sin(this.angle + Math.PI/2) * 8;
        const x2 = this.x - Math.cos(this.angle) * 20 - Math.cos(this.angle + Math.PI/2) * 8;
        const y2 = this.y - Math.sin(this.angle) * 20 - Math.sin(this.angle + Math.PI/2) * 8;
        if(Math.random()>0.5) particles.push(new Particle(x1, y1, -this.vx*0.5, -this.vy*0.5, '#00d2ff', 12));
        if(Math.random()>0.5) particles.push(new Particle(x2, y2, -this.vx*0.5, -this.vy*0.5, '#00d2ff', 12));
    }

    action() {
        this.fuel -= 0.3;
        
        let target = null;
        let type = 'none';
        
        // Target Logic
        let closestEnemy = null;
        let minEDist = this.laserRange;
        enemies.forEach(e => {
            let d = distance(this.x, this.y, e.x, e.y);
            if(d < minEDist && this.isFacing(e)) { minEDist = d; closestEnemy = e; }
        });

        if(closestEnemy) { target = closestEnemy; type = 'enemy'; } 
        else {
            let closestAst = null;
            let minADist = this.laserRange;
            asteroids.forEach(a => {
                let d = distance(this.x, this.y, a.x, a.y);
                if(d < minADist && this.isFacing(a)) { minADist = d; closestAst = a; }
            });
            if(closestAst) { target = closestAst; type = 'asteroid'; }
        }

        if (target) {
            ctx.beginPath();
            ctx.moveTo(this.x - camera.x, this.y - camera.y);
            ctx.lineTo(target.x - camera.x, target.y - camera.y);
            ctx.strokeStyle = type === 'enemy' ? '#ff3333' : '#00ff88';
            ctx.lineWidth = 2 + Math.random() * 3;
            ctx.stroke();

            particles.push(new Particle(target.x, target.y, randomRange(-2,2), randomRange(-2,2), ctx.strokeStyle, 8));

            target.hp -= this.miningPower;
            
            if (target.hp <= 0) {
                if(type === 'asteroid') this.collectResource(target);
                if(type === 'enemy') {
                    // Boss reward
                    if(target.isBoss) {
                        showNotification("DREADNOUGHT D√âTRUIT ! (+500$)", "#ffaa00");
                        playerData.credits += 500;
                        createExplosion(target.x, target.y, '#ffaa00', 100);
                        // Drop lots of loot
                        for(let i=0; i<5; i++) loots.push(new Loot(target.x + randomRange(-30,30), target.y + randomRange(-30,30)));
                    } else {
                        // Standard pirate
                        playerData.credits += 15;
                        createExplosion(target.x, target.y, '#ff3333', 25);
                        loots.push(new Loot(target.x, target.y));
                    }
                    const idx = enemies.indexOf(target);
                    if(idx > -1) enemies.splice(idx, 1);
                }
            }
        }
    }

    isFacing(obj) {
        const angleTo = Math.atan2(obj.y - this.y, obj.x - this.x);
        let diff = Math.abs(this.angle - angleTo);
        while(diff > Math.PI) diff -= 2*Math.PI;
        while(diff < -Math.PI) diff += 2*Math.PI;
        return Math.abs(diff) < 0.6;
    }

    collectResource(ast) {
        if (this.getCargoTotal() >= this.maxCargo) {
            showNotification("SOUTE PLEINE", "#ff3333");
            return;
        }
        let typeName = ast.type === 'iron' ? 'Fer' : ast.type === 'gold' ? 'Or' : 'Cristal';
        this.cargo[ast.type]++;
        popups.push(new Popup(ast.x, ast.y, `+1 ${typeName}`, ast.color));
        createExplosion(ast.x, ast.y, ast.color, 15);
        const index = asteroids.indexOf(ast);
        if (index > -1) asteroids.splice(index, 1);
        spawnAsteroid(true);
    }

    draw() {
        if (this.dead) return;
        const sx = this.x - camera.x;
        const sy = this.y - camera.y;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(this.angle);

        // Ship Body
        ctx.fillStyle = '#222';
        ctx.strokeStyle = '#00d2ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(18, 0); ctx.lineTo(-12, 14); ctx.lineTo(-8, 0); ctx.lineTo(-12, -14);
        ctx.closePath();
        ctx.fill(); ctx.stroke();
        
        // Shield Bubble (Visual only)
        if (this.shield > 1) {
            ctx.strokeStyle = `rgba(0, 136, 255, ${this.shield/this.maxShield * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(0,0, 22, 0, Math.PI*2); ctx.stroke();
        }

        // Cockpit
        ctx.fillStyle = '#0ff'; ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
        ctx.restore();
    }
}

class Enemy {
    constructor(isBoss = false) {
        this.isBoss = isBoss;
        let angle = Math.random() * Math.PI * 2;
        let dist = isBoss ? 2000 : 900; 
        this.x = player.x + Math.cos(angle) * dist;
        this.y = player.y + Math.sin(angle) * dist;
        
        this.vx = 0; this.vy = 0;
        this.angle = 0;
        
        if (isBoss) {
            this.hp = 500;
            this.maxHp = 500;
            this.speed = 1.0;
            this.radius = 40;
            this.color = '#aa0000';
            this.fireRate = 40;
        } else {
            this.hp = 35;
            this.maxHp = 35;
            this.speed = 2.8;
            this.radius = 15;
            this.color = '#ff3333';
            this.fireRate = 120;
        }
        this.reloadTime = 50;
    }

    update() {
        const d = distance(this.x, this.y, player.x, player.y);
        
        // Chase
        if (d < 1500) {
            const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
            let diff = targetAngle - this.angle;
            while (diff <= -Math.PI) diff += Math.PI*2;
            while (diff > Math.PI) diff -= Math.PI*2;
            this.angle += diff * (this.isBoss ? 0.02 : 0.06);

            this.vx += Math.cos(this.angle) * (this.isBoss ? 0.05 : 0.15);
            this.vy += Math.sin(this.angle) * (this.isBoss ? 0.05 : 0.15);
        }

        // Speed Limit
        const vel = Math.hypot(this.vx, this.vy);
        if (vel > this.speed) {
            this.vx = (this.vx / vel) * this.speed;
            this.vy = (this.vy / vel) * this.speed;
        }

        this.x += this.vx; this.y += this.vy;

        // Attack
        this.reloadTime--;
        if (d < (this.isBoss ? 600 : 400) && this.reloadTime <= 0) {
            this.shoot();
        }
    }

    shoot() {
        this.reloadTime = this.fireRate;
        if (this.isBoss) {
            // Spread Shot
            enemyProjectiles.push(new Projectile(this.x, this.y, this.angle, true));
            enemyProjectiles.push(new Projectile(this.x, this.y, this.angle + 0.3, true));
            enemyProjectiles.push(new Projectile(this.x, this.y, this.angle - 0.3, true));
        } else {
            enemyProjectiles.push(new Projectile(this.x, this.y, this.angle));
        }
    }

    draw() {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y;

        if(sx < -80 || sx > canvas.width+80 || sy < -80 || sy > canvas.height+80) return;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(this.angle);

        ctx.fillStyle = '#200';
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;

        if (this.isBoss) {
            // Boss Shape (Pentagon)
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(40 * Math.cos(i * 2 * Math.PI / 5), 40 * Math.sin(i * 2 * Math.PI / 5));
            }
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            // Boss Core
            ctx.fillStyle = '#f00';
            ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        } else {
            // Fighter
            ctx.beginPath();
            ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
        }

        ctx.restore();

        // HP Bar
        ctx.fillStyle = 'red';
        ctx.fillRect(sx - 20, sy - this.radius - 10, 40 * (this.hp/this.maxHp), 4);
    }
}

class Projectile {
    constructor(x, y, angle, isBig = false) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (isBig ? 5 : 7);
        this.vy = Math.sin(angle) * (isBig ? 5 : 7);
        this.life = 100;
        this.isBig = isBig;
        this.damage = isBig ? 25 : 10;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life--;
        // Collision with player
        if (distance(this.x, this.y, player.x, player.y) < player.radius + 8) {
            player.takeDamage(this.damage);
            this.life = 0;
            createExplosion(this.x, this.y, '#ff3333', 10);
        }
    }
    draw() {
        ctx.fillStyle = this.isBig ? '#ff0000' : '#ff5555';
        ctx.beginPath();
        ctx.arc(this.x - camera.x, this.y - camera.y, this.isBig ? 6 : 3, 0, Math.PI*2);
        ctx.fill();
    }
}

class Loot {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.type = Math.random();
        // 0-0.4: Cash, 0.4-0.7: Fuel, 0.7-1.0: Repair
        this.life = 600; // 10 seconds
        this.bobOffset = Math.random() * Math.PI * 2;
    }
    update() {
        this.life--;
        // Bobbing effect
        this.bobOffset += 0.05;
        
        // Magnet to player if close
        const d = distance(this.x, this.y, player.x, player.y);
        if (d < 150) {
            this.x += (player.x - this.x) * 0.05;
            this.y += (player.y - this.y) * 0.05;
        }

        if (d < player.radius + 15) {
            this.life = 0;
            if (this.type < 0.4) {
                const amt = Math.floor(randomRange(20, 50));
                playerData.credits += amt;
                popups.push(new Popup(this.x, this.y, `+${amt} $`, '#00ff00'));
            } else if (this.type < 0.7) {
                player.fuel = Math.min(player.maxFuel, player.fuel + 200);
                popups.push(new Popup(this.x, this.y, `CARBURANT`, '#ffaa00'));
            } else {
                player.hull = Math.min(player.maxHull, player.hull + 30);
                popups.push(new Popup(this.x, this.y, `R√âPARATION`, '#ff3333'));
            }
        }
    }
    draw() {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y + Math.sin(this.bobOffset)*5;
        let color = this.type < 0.4 ? '#00ff00' : (this.type < 0.7 ? '#ffaa00' : '#ff3333');
        
        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(this.bobOffset);
        ctx.fillStyle = color;
        ctx.fillRect(-6, -6, 12, 12);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(-6, -6, 12, 12);
        ctx.restore();
    }
}

class Asteroid {
    constructor(isSpawn = false) {
        let angle = Math.random() * Math.PI * 2;
        let dist = isSpawn ? randomRange(800, 1500) : randomRange(300, WORLD_SIZE);
        if (isSpawn) { this.x = player.x + Math.cos(angle) * dist; this.y = player.y + Math.sin(angle) * dist; } 
        else { this.x = Math.cos(angle) * dist; this.y = Math.sin(angle) * dist; }
        
        this.radius = randomRange(20, 50);
        this.hp = this.radius * 2;
        this.rotation = 0;
        this.rotSpeed = randomRange(-0.02, 0.02);
        
        const rand = Math.random();
        if (rand > 0.90) { this.type = 'crystal'; this.color = '#d0f'; this.hp *= 2.5; }
        else if (rand > 0.70) { this.type = 'gold'; this.color = '#fd0'; this.hp *= 1.5; }
        else { this.type = 'iron'; this.color = '#89a'; }

        this.points = [];
        const sides = Math.floor(randomRange(6, 12));
        for(let i=0; i<sides; i++) {
            const a = (i / sides) * Math.PI * 2;
            const r = this.radius * randomRange(0.7, 1.3);
            this.points.push({x: Math.cos(a)*r, y: Math.sin(a)*r});
        }
    }

    update() {
        this.rotation += this.rotSpeed;
        if (distance(this.x, this.y, player.x, player.y) < this.radius + player.radius) {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            player.vx += Math.cos(angle) * 1.5; player.vy += Math.sin(angle) * 1.5;
            player.takeDamage(this.radius / 2);
            createExplosion(player.x, player.y, '#fff', 5);
        }
    }

    draw() {
        const sx = this.x - camera.x; const sy = this.y - camera.y;
        if (sx < -100 || sx > canvas.width + 100 || sy < -100 || sy > canvas.height + 100) return;

        ctx.save(); ctx.translate(sx, sy); ctx.rotate(this.rotation);
        ctx.fillStyle = '#1a1a25'; ctx.strokeStyle = this.color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y);
        for(let i=1; i<this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
        ctx.closePath(); ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = this.color; ctx.globalAlpha = 0.3; ctx.fill(); ctx.globalAlpha = 1;
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, vx, vy, color, life) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.color = color; this.life = life; this.maxLife = life;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw() {
        const sx = this.x - camera.x; const sy = this.y - camera.y;
        ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color;
        ctx.fillRect(sx, sy, 3, 3); ctx.globalAlpha = 1;
    }
}

class Popup {
    constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.life = 60; }
    draw() {
        this.y -= 0.5; this.life--;
        const sx = this.x - camera.x; const sy = this.y - camera.y;
        ctx.fillStyle = this.color; ctx.font = 'bold 16px Roboto';
        ctx.strokeStyle = 'black'; ctx.lineWidth = 3;
        ctx.strokeText(this.text, sx, sy); ctx.fillText(this.text, sx, sy);
    }
}

// --- INIT & UTILS ---
const player = new Ship();
const camera = new Camera();

for(let i=0; i<400; i++) stars.push({x: randomRange(-WORLD_SIZE, WORLD_SIZE), y: randomRange(-WORLD_SIZE, WORLD_SIZE), size: Math.random() * 2.5, alpha: Math.random()});

function spawnAsteroid(respawn = false) { asteroids.push(new Asteroid(respawn)); }
for(let i=0; i<80; i++) spawnAsteroid();

function createExplosion(x, y, color, count) {
    for(let i=0; i<count; i++) particles.push(new Particle(x, y, randomRange(-3,3), randomRange(-3,3), color, randomRange(20,40)));
}

// --- GAME LOOP ---
function update() {
    if (currentState !== GAME_STATE.PLAYING) return;

    player.update();
    camera.follow(player);

    // Spawners
    if (Math.random() < ENEMY_SPAWN_RATE && enemies.length < 4 && distance(player.x, player.y, 0, 0) > 1000) {
        enemies.push(new Enemy(false));
        showNotification("Signal Pirate D√©tect√©", "#ff3333");
    }

    // Boss Logic
    bossSpawnTimer++;
    if (bossSpawnTimer > BOSS_INTERVAL) {
        if (!enemies.some(e => e.isBoss)) {
            document.getElementById('boss-warning').style.display = 'block';
            setTimeout(() => {
                document.getElementById('boss-warning').style.display = 'none';
                enemies.push(new Enemy(true)); // Spawn Boss
            }, 3000);
            bossSpawnTimer = 0;
        }
    }

    asteroids.forEach(a => a.update());
    enemies.forEach(e => e.update());
    loots.forEach((l, i) => { l.update(); if(l.life <= 0) loots.splice(i, 1); });

    for(let i=enemyProjectiles.length-1; i>=0; i--) {
        let p = enemyProjectiles[i]; p.update();
        if(p.life <= 0) enemyProjectiles.splice(i, 1);
    }
    
    // Cleanups
    for(let i=particles.length-1; i>=0; i--) { particles[i].update(); if(particles[i].life <= 0) particles.splice(i, 1); }
    for(let i=popups.length-1; i>=0; i--) { if(popups[i].life <= 0) popups.splice(i, 1); }

    updateUI();
}

function draw() {
    ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const cx = -camera.x; const cy = -camera.y;
    const grad = ctx.createRadialGradient(cx, cy, 100, cx, cy, 3000);
    grad.addColorStop(0, '#102040'); grad.addColorStop(1, '#050510');
    ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, canvas.height);

    ctx.fillStyle = 'white';
    stars.forEach(s => {
        let sx = ((s.x - camera.x * 0.05) % canvas.width + canvas.width) % canvas.width;
        let sy = ((s.y - camera.y * 0.05) % canvas.height + canvas.height) % canvas.height;
        ctx.globalAlpha = s.alpha; ctx.fillRect(sx, sy, s.size, s.size);
    });
    ctx.globalAlpha = 1;

    // Station
    const statX = -camera.x; const statY = -camera.y;
    ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(statX, statY, STATION_SIZE/2, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#00d2ff'; ctx.lineWidth = 4; ctx.stroke();
    
    // Objects
    loots.forEach(l => l.draw());
    asteroids.forEach(a => a.draw());
    particles.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
    enemyProjectiles.forEach(p => p.draw());
    player.draw();
    popups.forEach(p => p.draw());

    // Arrow
    const dist = distance(player.x, player.y, 0, 0);
    if (dist > canvas.height/2) {
        const ang = Math.atan2(-player.y, -player.x);
        const arrowX = canvas.width/2 + Math.cos(ang) * 100;
        const arrowY = canvas.height/2 + Math.sin(ang) * 100;
        ctx.save(); ctx.translate(arrowX, arrowY); ctx.rotate(ang);
        ctx.fillStyle = '#00d2ff'; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 7); ctx.lineTo(-10, -7); ctx.fill();
        ctx.restore();
        ctx.fillStyle = 'white'; ctx.font = "12px Orbitron"; ctx.textAlign = "center";
        ctx.fillText(Math.floor(dist/10) + "m", arrowX, arrowY + 20);
    }
}

function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

// --- UI LOGIC ---
function updateUI() {
    document.getElementById('shield-bar').style.width = Math.max(0, (player.shield / player.maxShield * 100)) + '%';
    document.getElementById('hull-bar').style.width = Math.max(0, (player.hull / player.maxHull * 100)) + '%';
    document.getElementById('fuel-bar').style.width = Math.max(0, (player.fuel / player.maxFuel * 100)) + '%';
    document.getElementById('cargo-bar').style.width = (player.getCargoTotal() / player.maxCargo * 100) + '%';
    
    document.getElementById('shield-val').innerText = Math.floor(player.shield/player.maxShield*100) + "%";
    document.getElementById('hull-val').innerText = Math.floor(player.hull/player.maxHull*100) + "%";

    document.getElementById('credits-display').innerText = playerData.credits;
    document.getElementById('cargo-text').innerText = `${player.getCargoTotal()} / ${player.maxCargo}`;
    document.getElementById('res-iron').innerText = player.cargo.iron;
    document.getElementById('res-gold').innerText = player.cargo.gold;
    document.getElementById('res-crystal').innerText = player.cargo.crystal;

    // Radar
    const radar = document.getElementById('radar');
    while(radar.children.length > 1) { radar.removeChild(radar.lastChild); }
    createBlip(60, 60, 'white'); // Player center
    const range = 2000; const scale = 60 / range;
    
    asteroids.forEach(a => {
        let dx = a.x - player.x; let dy = a.y - player.y;
        if(Math.abs(dx) < range && Math.abs(dy) < range) createBlip(60 + dx*scale, 60 + dy*scale, a.color, 2);
    });
    enemies.forEach(e => {
        let dx = e.x - player.x; let dy = e.y - player.y;
        if(Math.abs(dx) < range && Math.abs(dy) < range) createBlip(60 + dx*scale, 60 + dy*scale, e.isBoss ? '#f00' : '#d55', e.isBoss ? 6 : 3);
    });
    loots.forEach(l => {
        let dx = l.x - player.x; let dy = l.y - player.y;
        if(Math.abs(dx) < range && Math.abs(dy) < range) createBlip(60 + dx*scale, 60 + dy*scale, '#0f0', 3);
    });
    // Station
    let sdx = -player.x; let sdy = -player.y;
    if(Math.abs(sdx) < range && Math.abs(sdy) < range) createBlip(60 + sdx*scale, 60 + sdy*scale, '#00d2ff', 6);
}

function createBlip(x, y, color, size) {
    if(x<0 || x>120 || y<0 || y>120) return;
    const d = document.createElement('div');
    d.className = 'radar-blip';
    d.style.left = x + 'px'; d.style.top = y + 'px';
    d.style.backgroundColor = color; d.style.width = size+'px'; d.style.height = size+'px';
    document.getElementById('radar').appendChild(d);
}

function showNotification(msg, color='#fff') {
    const area = document.getElementById('notification-area');
    const el = document.createElement('div');
    el.className = 'message';
    el.innerText = msg; el.style.borderLeftColor = color;
    area.appendChild(el); setTimeout(() => { el.remove(); }, 2500);
}

// Menu Functions
function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    player.reset();
    currentState = GAME_STATE.PLAYING;
    gameLoop();
}

function openStation() {
    currentState = GAME_STATE.STATION;
    document.getElementById('station-menu').style.display = 'block';
    let val = (player.cargo.iron * 15) + (player.cargo.gold * 60) + (player.cargo.crystal * 120);
    document.getElementById('sell-value').innerText = val;
    updateUpgradeUI();
    player.vx = 0; player.vy = 0; player.x = 0; player.y = 0;
}

function closeStation() {
    document.getElementById('station-menu').style.display = 'none';
    player.y = 250; currentState = GAME_STATE.PLAYING; saveGame();
}

function sellResources() {
    let val = (player.cargo.iron * 15) + (player.cargo.gold * 60) + (player.cargo.crystal * 120);
    if (val > 0) {
        playerData.credits += val;
        player.cargo = { iron: 0, gold: 0, crystal: 0 };
        document.getElementById('sell-value').innerText = "0";
        showNotification("Vente confirm√©e", "#00ff88");
        updateUpgradeUI(); saveGame();
    }
}

function refillServices() {
    if (playerData.credits >= 50) {
        playerData.credits -= 50;
        player.fuel = player.maxFuel; player.hull = player.maxHull; player.shield = player.maxShield;
        showNotification("Maintenance termin√©e", "#00d2ff");
        updateUpgradeUI();
    } else showNotification("Cr√©dits insuffisants", "#ff3333");
}

const COSTS = { speed: l=>100*l, laser: l=>150*l, cargo: l=>200*l, hull: l=>150*l, shield: l=>250*l };

function updateUpgradeUI() {
    document.getElementById('credits-display').innerText = playerData.credits;
    ['speed', 'laser', 'cargo', 'hull', 'shield'].forEach(t => {
        const lvl = playerData.upgrades[t];
        const cost = COSTS[t](lvl);
        document.getElementById(`lvl-${t}`).innerText = `LVL ${lvl}`;
        document.getElementById(`cost-${t}`).innerText = cost;
        document.getElementById(`btn-up-${t}`).disabled = playerData.credits < cost;
    });
}

function buyUpgrade(type) {
    const lvl = playerData.upgrades[type];
    const cost = COSTS[type](lvl);
    if(playerData.credits >= cost) {
        playerData.credits -= cost;
        playerData.upgrades[type]++;
        player.applyStats();
        updateUpgradeUI(); saveGame();
        showNotification("Module am√©lior√©", "#00d2ff");
    }
}

function die(reason) {
    currentState = GAME_STATE.GAMEOVER;
    player.dead = true;
    document.getElementById('death-reason').innerText = reason;
    document.getElementById('game-over-screen').style.display = 'block';
    player.cargo = { iron: 0, gold: 0, crystal: 0 };
    saveGame();
}

function respawn() {
    document.getElementById('game-over-screen').style.display = 'none';
    player.reset();
    currentState = GAME_STATE.PLAYING;
}

loadGame();
document.getElementById('start-screen').style.display = 'block';

</script>
</body>
</html>